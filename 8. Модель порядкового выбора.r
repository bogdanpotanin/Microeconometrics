# --------
# Потанин Богдан Станиславович
# Микроэконометрика в R :)
# Урок 8. Модель порядкового выбора
# --------

# Отключим scientific notation
options(scipen = 999)

#---------------------------------------------------
# Часть 1. Оценивание параметров и тест Бранта
#---------------------------------------------------

# Подключим дополнительные библиотеки
library("mvtnorm")                                       # симуляции из многомерного
                                                         # нормального распределения
library("numDeriv")                                      # численное дифференцирование
library("brant")                                         # тест Бранта о parallel lines
library("MASS")                                          # порядковый пробит и логит

# Воспроизведем процесс генерации данных,
# предполагаемый пробит моделью порядкового выбора
# Симулируем данные
set.seed(123)                                            # для воспроизводимости
n <- 10000                                               # число наблюдений                  
X <- rmvnorm(n,                                          # симулируем n наблюдений из многомерного
                                                         # нормального распределения
             c(0, 0, 0),                                 # с нулевым вектором математических ожиданий и
             matrix(c(1, 0.2, 0.3,                       # следующей ковариационной матрице
                      0.2, 1, -0.1,
                      0.3, -0.1, 1),
                    ncol = 3,
                    byrow = FALSE))
X[, 2] <- X[, 2] > 0.5                                   # сделаем регрессор X2 бинарным
X <- cbind(1, X)                                         # добавим константу как дополнительный регрессор
u <- rnorm(n, 0, 1)                                      # ошибки из стандартного нормально распределения

# Соберем регрессоры в датафрейм
h <- data.frame("income" = X[, 2],                       # показатель, отражающий уровень
                                                         # развития профессиональных равыков
                "male" = X[, 3],                         # пол: мужчина = 1, женщина = 0
                "experience" = X[, 4],                   # показатель, отражающий опыт работы
                "educ" = runif(n))                       # показатель веса, симулированный из
                                                         # стандартного равномерного распределения

# Создадим линейный индекс, который определяет
# зависимость латентной переменной от различных
# независимых переменных
gamma <- c(0.1, 0.2, 0.3, -0.05, 0.5, 0)                 # линейный индекс с
z_li <- gamma[1] * h$income +                            # образованием
        gamma[2] * h$male +                              # полом
        gamma[3] * h$experience +                        # опытом
        gamma[4] * h$experience ^ 2 +                    # квадратом опыта
        gamma[5] * h$income * h$male +                   # взаимодействием навыков и образования
        gamma[6] * h$educ                                # доходом
z_star <- z_li + u

# Введем пороги
mu <- c(0, 0.5, 1.2)

# Создадим наблюдаемую зависимую переменную,
# отражающую оценку индивидом качества
# своего здоровья
z <- rep(0, n)                                           # наблюдаемое значение переменной
z[(z_star > mu[1]) & (z_star <= mu[2])] <- 1
z[(z_star > mu[2]) & (z_star <= mu[3])] <- 2
z[(z_star > mu[3])] <- 3
z <- matrix(z, ncol = 1)                                 # как матрица с одним столбцом 
h$health <- z                                            # добавим в датафрейм переменную 
                                                         # на трудоустройство
summary(as.factor(h$health))                             # посмотрим доли

#*******************************
# Пользовательский уровень
#*******************************

# Воспользуемся пробит модель, предварительно перекодировав health
h$health_binary <- h$health >= 2

model_probit <- glm(formula = health_binary ~ income + male +       # указываем формулу без константы, поскольку
                              experience + I(experience ^ 2) +      # она учитывается автоматически
                              I(income * male) +
                              educ,                                                 
                    data = h,                                       # датафрейм, из которого берутся зависимая
                                                                    # и независимые переменные
                    family = binomial(link = "probit"))             # тип оцениваемой бинарной регрессии: в данном
                                                                    # случае используется пробит регрессия и для ее
                                                                    # замены на логит измените "probit" на "logit"
summary(model_probit) 

# Применим порядковую модель
model_oprobit <- polr(formula = as.factor(health) ~                 # зависимую переменную необходимо
                                income + male +                     # преобразовать в факторную, что
                                experience + I(experience ^ 2) +    # можно сделать прямо в формуле
                                I(income * male) +
                                educ,                                                 
                      data = h,                                       
                      method = "probit")                            # можно заменить на logistic             
summary(model_oprobit)    

# Сравним истинные и полученные оценки границ
data.frame("True Thresholds" = mu,
           "Est Thresholds" = model_oprobit$zeta)

# Сравним точность оценок
gamma_probit <- coef(model_probit)[-1]                              # пробит оценки без константы
gamma_oprobit <- coef(model_oprobit)                                # оценки порядкового пробита
data.frame("Real" = gamma,
           "Probit" = gamma_probit,
           "Ordered" = gamma_oprobit,
           "MSE Probit" = (gamma_probit - gamma) ^ 2,
           "MSE Ordered" = (gamma_oprobit - gamma) ^ 2)

# Проведем тест Бранта
brant(model_oprobit)

# ЗАДАНИЯ (* - непросто, ** - сложно, *** - брутально)
# 1.1.    Разбейте уровни здоровья на две категории
#         альтернативным способом и убедись, что
#         оценки регрессионных коэффициентов окажутся
#         достаточно близки к истине
# 1.2.    Разбейте уровни здоровья на три категории
#         и проверьте, насколько точными окажутся оценки.
#         Сравните результаты данного и предыдущего
#         заданий.
# 1.3*.   Проверьте, как изменятся результаты теста
#         Бранта при:
#         1)     некорректной спецификации
#                линейного индекса
#         2)     гетероскедастичных случайных ошибках
#         3)     если случайная ошибка имеет
#                распределение Стьюдента с пятью
#                степенями свободы
#         4)     если произвести оценивание параметров 
#                модели объединив последние две категории
#                в одну

#---------------------------------------------------
# Часть 2. Расчет вероятностей и предельных эффектов
#---------------------------------------------------

#*******************************
# Пользовательский уровень
#*******************************

# Оценим вероятности
probs_oprobit <- predict(model_oprobit, type = "probs")             # порядковый пробит
probs_probit <- predict(model_probit, type = "response")            # пробит

# Сравним вероятности попадания не менее, чем
# во вторую категорию
data.frame("Probit" = probs_probit,
           "Ordered" = probs_oprobit[, 3] + probs_oprobit[, 4])

#*******************************
# Продвинутый пользовательский уровень
#*******************************

# Оценим предельный эффект опыта на вероятность
# попадания во вторую категорию
X_oprobit <- model.frame(model_oprobit)[, -1]                       # достаем матрицу независимых переменных
X_oprobit <- as.matrix(X_oprobit)                                   # из порядковой пробит модели
z_li_est <- X_oprobit %*% gamma_oprobit
ME_experience <- (gamma_oprobit["experience"] +                     # часть, обусловленная формой, в которой
                  2 * gamma_oprobit["I(experience^2)"] *            # переменная входит в линейный индекс
                  X_oprobit[, "experience"]) *
                  (dnorm(mu[3] - z_li_est) -                        # часть, общая для предельных эффектов
                   dnorm(mu[2] - z_li_est))                         # всех переменных

# ЗАДАНИЯ (* - непросто, ** - сложно, *** - брутально)
# 2.1.    Оцените предельный эффект:
#         1)     пола
#         2)     дохода
#         3)     образования
# 2.2*.   Повторите предыдущий пункт, используя
#         численную оптимизацию
# 2.3.    Сравните вероятности попадания в последнюю
#         категорию по пробит и порядковой моделям
# 2.4.    Самостоятельно запрограммируйте процедуры,
#         позволяющие оценивать:
#         1**)   порядковую пробит модель с
#                гетероскедастичной случайной ошибкой
#         2***)  систему из двух порядковых уравнений
#         3***)  порядковую модель со случайными эффектами

#---------------------------------------------------
# Часть 3. Порядковая логистическая модель
#---------------------------------------------------

# Строго говоря в процессе генерации данных нужно заменить
# u <- rnorm(n, 0, 1)
# на
# u <- rlogis(n)

# Применим порядковую модель
model_ologit <- polr(formula = as.factor(h$health) ~                # зависимую переменную необходимо
                               income + male +                      # преобразовать в факторную, что
                               experience + I(experience ^ 2) +     # можно сделать прямо в формуле
                               I(income * male) +
                               educ,                                                 
                      data = h,                                       
                      method = "logistic")                          # можно заменить на logistic             
summary(model_ologit)

# При интерпретации отношений шансов учитывайте, что для 
# любого номера категории k изменение в отношениях шансов 
# p(z>k)/p(z<=k) остается прежним Рассчитаем изменение в 
# отношениях шансов p(z>k)/p(z<=k) при изменении независимой 
# переменной, входящей в основное уравнение, на единицу
OR_educ <- exp(gamma_oprobit["educ"])

# ЗАДАНИЯ (* - непросто, ** - сложно, *** - брутально)
# 3.1.    Оцените изменение в отношениях шансов при
#         изменении на единицу:
#         1*)    пола
#         2*)    дохода
#         3*)    опыта